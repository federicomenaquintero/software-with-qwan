Software that has the Quality Without A Name

When I was learning how to program, I noticed that I frequently hit
the same problem over and over again:  I would often write a program
that worked reasonably well, but after some time of modifying it and
enhancing it, I could no longer tweak it any further.  Either its
complexity would overwhelm me, or it would be so tightly written that
it allowed no room for expansion, like a house where you cannot build
up because it has a sloping roof, and you cannot build to the sides
because it has a wall all around it.

As I got better, I learned to deal with complexity.  We all learn how
to do that with various tools and techniques:  abstraction,
encapsulation, object-orientation, functional techniques, etc.  We
learn how various techniques let us write broader programs.

However, the problem of having a program that was too tight to modify
still persisted.  Sometimes I had what I thought was a beautiful
design, but modifying it in any way would "break it" and I did not want
that.  Other times I had something with so many interconnected parts,
that I just could not plug anything else into it or the whole thing
would fall down under its own weight.

Some years ago the whole "Refactoring" craze started, but I did not
pay much attention to it.  I said, sure, it is a way to clean up your
code, but so what?  I already know how to take a chunk of code and
turn it into a function; I already know how to take similar chunks of
code and turn them into derived classes.  What's the big deal?

I dismissed "Refactoring" as something suited to less-experienced
programmers; as some nice recipes for cleaning up your code, but nothing
that you could live without.

The same thing happened to me with "Design Patterns".  I thought they
were just giving pompous names like Singleton and Strategy to the
everyday kinds of structures one would naturally put in a program.

Maybe my ego as a programmer was too inflated to consider those works
seriously.  But then, something happened.

Christopher Alexander's work

At times, while browsing the web, I'll sometimes remember that I have
seen the name of a certain author before, or the title of a book, or
something like that.  I may have not really paid attention to it in
the past, but somehow, the more times I see the same thing mentioned,
the more likely it is that I will get interested enough in it to
actually see what it is about.  "Oh, several people have already
mentioned this name or this book; maybe I should check it out."

That is just what happened with the name of Christopher Alexander.  I
had read that he was a peculiar architect (of real-world buildings,
not software), somehow connected to the software world through
object-oriented techniques.  As I started reading about his work, I
became tremendously interested in it.

At that exact time, my wife and I had recently bought a small,
one-storey house and we wanted to expand it.  We were thinking of
having a child, so we needed more space.  I needed a real home-office,
not just a leftover alcove where my desk and bookcases barely fit.  As
avid cooks, we both needed a kitchen that was larger and more
comfortable the one the house had.  My wife needed a Room Of Her Own.

We did not want to pay for an expensive architect, and neither of us
knew anything about construction.  How would we design our house?

In the 1970s, Christopher Alexander was a mathematician/architect
teaching at the University of California, Berkeley.  He and a group of
like-minded architects went to various places around the world,
ttrying to see if there were reasons for why there are human-built
places in the world (cities, towns, parks, buildings, houses) where it
is very pleasant to be, those that are comfortable, livable, and
*nice*, and some places where this is not the case.  The pleasant
places were present in all of the traditional architectures of the
world - European, African, Asian, American - which pointed to the idea
of being able to extract common factors from all of them.

Alexander and his team distilled their findings into a list of good
architectural patterns, and published three books:  "The Timeless Way
of Building", where they describe the philosophy and method of good
architecture; "A Pattern Language", which I'll describe next; and "The
Oregon Experiment", where they detail the design and construction of a
university campus with their method.

A Pattern Language

A *pattern* is a recurring problem when designing and building things,
with a discussion of the forces that shape the problem, and with a
solution that is in turn connected, almost recursively, to other
super- or sub-patterns.  For example, let's consider the "INTIMACY
GRADIENT", an important pattern in the book (patterns are spelled in
capital letters throughout the book for easy identification; I'll do
the same):

INTIMACY GRADIENT

Super-patterns and preamble:  ... if you know roughly where you intend
to place the building wings - WINGS OF LIGHT, and how many stories
they will have - NUMBER OF STORIES, and where the MAIN ENTRANCE is, it
is time to work out the rough disposition of the major areas on every
floor.  In every building the relationship between the public areas
and private areas is most important.

Statement of problem: Unless the spaces in a building are arranged in
a sequence which corresponds to their degrees of privateness, the
visits made by strangers, friends, guests, clients, family, will
always be a little awkward.

Discussion:  I will not quote all of it.  But for example, consider an
apartment where you can only reach the bathroom by first crossing the
bedroom.  Visits are always awkward because you feel like you need to
tidy up your room first, if you intend your visitors to be able to use
the WC!  Or in an office, you don't want a "quiet work space" to be
right next to the reception, because then it will not be quiet at all
- you want it to be more private, towards the back.

Summary of the solution: Lay out the spaces of a bulding so that they
create a sequence which begins with the entrance and the most public
parts of the building, then leads into the slightly more private
areas, and finally to the most private domains.

Sub-patterns to consult: COMMON AREAS AT THE HEART.  ENTRANCE ROOM for
houses; A ROOM OF ONE'S OWN for individuals.  RECEPTION WELCOMES YOU
for offices, HALF-PRIVATE OFFICE at the back.

"A Pattern Language" is remarkable for several reasons.  First, it is
immensely practical.  If you are building something, you can grab the
book and instantly get hundreds of ideas for your project.  Second, it
is not about a particular style or about superfluous decoration.  The
book doesn't tell you, "make this shape of flourishes in the
handrails"; instead it tells you, "a house should have its rooms
placed such that sunlight enters them according to the right time of
the day - East for the bedrooms in the morning, West for the living
room in the afternoon".  Third, you can see a whole philosophy of good
living emerge from the book.  It advocates a process that allows you
to construct an environment that respects your needs as an individual,
as a social human being, and as a living being that should not damage
its environment.

I had gotten a copy of "A Pattern Language" shortly before starting
the expansion of our house.  The book was a revelation:  *this* was
the way to approach the design of our house, and now we could do it
ourselves instead of paying a lot of money for an inadequate solution.

The patterns get quite specific, but they never impose a style or an
actual shape for the result.  For example, there is a pattern called
OPEN SHELVES.  Deep cupboards make you put things behind other things,
so you can't see them nor reach them.  They also have a big footprint.
Cupboards that are one-item-deep automatically stay tidy, and you
always know at a glance where everything is.  Things that you use
frequently should not be behind doors.

So you can see the essence of design patterns:  good, tested recipes
that don't constrain your implementation in unnecessary ways.

"Design Patterns", the well-known book by Gamma et al, took direct
inspiration from Alexander's architectural patterns.  They wanted to
do the same thing:  to make a list of problems that appear frequently
when programming, and to present good solutions for them, that
wouldn't constrain your implementation unnecessarily.

One thing that I realized until much later - a valuable thing from
either list of patterns, the architectural or the software one, is
that it gives us a *vocabulary* to talk about how things are
constructed.  It is much more convenient to say, "this object has
listeners for its properties", than "this object lets you hook
callback functions that are called when its properties change".  What
I thought were only pompous names, are in fact ways to express
knowledge in a compact form.

Much of Alexander's discussion of patterns and their philosophy refers
something which he calls the "Quality Without A Name".  You know
places with the Quality Without A Name.  It is the coffee shop where
you like to go to read, because the afternoon light hits it at just
the right intensity, and there are comfortable seats and tables.  It
is the corner in a park where a tree shades a bench, maybe there is
some water running, and no matter if it rains or if it is sunny, it
always seems to be a pleasure to be there.  Think of a Hobbit House,
where everything is at hand, everything is comfortable, and everything
is lovingly made.

A thing or place has the quality without a name if it is comfortable,
has evolved over time in its own terms, is free of inner
contradictions, doesn't try to draw attention to itself, and seems to
have archetypal qualities - like if it were *the* way that thing was
supposed to be built.  This seems like a very vague definition, but
that is as far as Alexander was able to take it during this first
phase of his work.  The real revelation would come later.

The Nature of Order

Although Christopher Alexander knew that he had produced something valuable
with his investigation and catalog of patterns, he was not completely
satisfied.  Where had the patterns come from?  Could we make new
patterns from scratch, or must be we content with what traditional
architecture has managed to evolve so far?  Are patterns necessary at all?  How
can we better define, and evaluate or measure, the Quality Without A Name?

Alexander spent the next twenty years researching those questions.  By
studying the actual *process* by which good built environments had
been created, he discovered that processes of a certain kind are
essential to creating good towns, or buildings, or any man-made thing.
He arrived at the following conclusions:

* Nature creates things that all have about 15 properties in common
(I'll show you later).  This happens solely through natural processes
- standard physics and chemistry - although it is not quite clear why
very different processes produce similar results.

* Traditional architectures, or towns which just evolved over time,
<em>also<em> have those properties.  You can derive all the patterns
in "A Pattern Language" by following a certain process based on those
properties.

* Each property can also describe a <em>transformation</em> to the
existing space.

* The only way to achieve good design is by using those
transformations, one at a time.

This was published in 2003-2004 in four volumes titled
"The Nature of Order".

The fifteen properties

The first book in "The Nature of Order" deals with fifteen properties
that appear in all natural systems.  I will summarize them very
briefly; see the references for pictures and more extensive
explanations.

	    <table frame="box" rules="all" cellpadding="10px">
	      <tbody valign="top">
		<tr>
		  <td>
		    <strong>Levels of scale.</strong>  There is a
		    balanced range of sizes.  You don't have abrupt
		    changes in the sizes of adjacent things.  Elements
		have fractal scale.
		  </td>
		  <td>
		    <strong>Strong centers.</strong>  You can clearly
		    identify parts of the space or structure.
		  </td>
		  <td>
		    <strong>Thick boundaries.</strong>  Lines delimit
		    things.  In living systems, edges are the most
		    productive environments (e.g. all the critters
		    that live at the edge of the water).
		  </td>
		</tr>
		<tr>
		  <td>
		    <strong>Alternating repetition.</strong>
		    High/low, thick/thin, shape&nbsp;A and
		    shape&nbsp;B.  Things oscillate and alternate to
	      create a good balance.
		  </td>
		  <td>
		    <strong>Positive space.</strong>  Space is
		    beautifully shaped, convex, enclosed.  It is not
		    leftover space.  Think of how a Voronoi diagram
	      has cells that grow outward from a bunch of points, or
	      how a piece of corn has kernels that grow from tiny
	      points until they touch the adjacent kernels.
		  </td>
		  <td>
		    <strong>Good shape</strong>.  The sails of a ship,
		    the shell of a snail, the beak of a bird.  They
		    attain the optimal shape for their purpose, which is beautiful.
		  </td>
		</tr>
		<tr>
		  <td>
		    <strong>Local symmetries.</strong>  The world is
		    not symmetrical at large.  But small things tend
		    to be symmetrical, because it is easier that way.
		    Your house is not symmetrical, but each window is.
		  </td>
		  <td>
		    <strong>Deep interlock and ambiguity.</strong>
		    The crooked streets of old towns.  Axons in
		    neurons.  It is hard to separate figure and
	      ground, or foreground and background.  Two strong centers are made stronger if
		    a third center is placed between them, so that it
		    belongs to both.
		  </td>
		  <td>
		    <strong>Contrast.</strong>  You can distinguish
		    where one thing ends and the next one begins,
		    because they don't fade into each other.
		  </td>
		</tr>
		<tr>
		  <td>
		    <strong>Gradients.</strong>  Things fade into each
		    other where they need to.  Concentrations in
		    solutions, snow or earth banks, the wires that
		    support a bridge.  The way bandwidth decreases as
	      you move away from the backbone.
		  </td>
		  <td>
		    <strong>Roughness.</strong>  The world is not
		    frictionless and smooth.  Irregularities are good
	      because they let each piece adapt perfectly to its
	      surroundings, rather than being an exact copy that may
	      not fit as well.
		  </td>
		  <td>
		    <strong>Echoes.</strong> Things repeat and echo
		    each other.  Things are unique in their exact
		    shape, but the general shapes repeat over and over.
		  </td>
		</tr>
		<tr>
		  <td>
		    <strong>The void.</strong>  Sometimes you get a
		    big blank area for quietness of form.  A lake, a
		    courtyard, a picture window.
		  </td>
		  <td>
		    <strong>Simplicity and inner calm.</strong>
		    Things are as simple as possible, but no simpler.
		  </td>
		  <td>
		    <strong>Non-separateness.</strong> Everything
		    depends on everything else.  You can't separate a
		    fish from the pond and the aquatic plants.  You
		    can't separate a column from the base of the
		    building.
		  </td>
		</tr>
	      </tbody>
	    </table>

	    <p>
	      <strong>Structure-preserving transformations</strong>
	    </p>

	    <p>
	      The second book in <em>The Nature of Order</em>
	      describes how each of those properties also defines a
	      transformation.  For example:
	    </p>

	    <p> <strong>Thick boundaries.</strong> You can sometimes
	      transform something beneficially by <em>adding</em> a
	      boundary to it.  You plant a hedge around a garden,
	      which then serves as beauty, as a wind-break so that
	      strong winds don't damage the garden, and as a
	      productive system on its own.  In a graphical user
	      interface, scrollable boxes without a frame are hard to
	      distinguish from the window's background (think of "all
	      white" web pages with text entry boxes that don't have a
	      frame).  You put a cornice at the top of a building, so
	      that you don't get an abrupt transition between the building
	      and the sky.  </p>

	    <p>
	      <strong>Local symmetries.</strong>  Small parts of built
	      things are easier to build symmetrically &mdash; because
	      they are turned on a lathe, because they need access
	      from both sides, because they fold like a book.  Making
	      things asymmetrical "just to be interesting" takes extra
	      work and it is harder to make them work well.
	    </p>

	    <p>
	      <strong>Positive space.</strong> Feeling too exposed
	      when in your desk?  Add a waist-high bookshelf beside
	      you to delimit your space, but not to completely close
	      you off.  Does your user interface feel like a lot of
	      leftover space after you place the controls?  Make the
	      controls surround the usable space instead.
	    </p>

	    <p>
	      Each of these is a
	      <em>structure-preserving&nbsp;transformation</em>.  You
	      make a change in the existing structure not by tearing
	      it down and remaking it, but by tweaking one thing at a
	      time according to those properties and transformations.
	    </p>


It turns out that this is what much of "Refactoring" is about, when you
translate the concepts to code.  By extracting a chunk of code and
putting it in a function with a name, you are essentially adding a
thick boundary around that code, and creating a strong center.  By
removing a global variable and adding class variables, you are
allowing for roughness, as every instance can now have a different value in
that variable, as needed.  By having a producer/consumer, or
notifier/listener, you have a local symmetry, deep interlock and
ambiguity, and good shape.

Richard Gabriel, one of the principal figures in Common Lisp, studied
how to apply Alexander's theories to software (and also to poetry, and
isn't code similar to poetry after all?).  

	    <p>
	      <strong>The fundamental process</strong>
	    </p>

	    <p>
	      Over a long argument, Alexander explains why following
	      this process of applying structure-preserving
	      transformations is the <em>only</em> way to achieve a
	      good, functional design.  This is not just for
	      buildings, but for everything we construct.  We mimic
	      nature, but we do it faster.
	    </p>

	    <p>
	      So, how do you do one step in your design/implementation
	      process?
	    </p>

	    <p>
	      1. Start with what you have &mdash; an empty lot, or an
	      already-built building, or a program that looks ugly and
	      is hard to use.
	    </p>

	    <p>
	      2. Identify the centers that exist in that space.  Find
	      the weakest center or the least coherent.
	    </p>

	    <p>
	      3. See how to apply one or more of the fifteen
	      structure-preserving transformations to strengthen that
	      weak center.  Does it need to be delimited?  Does it
	      need to be blended with its surroundings?  Does it need
	      more detail?  Does it need to be de-cluttered?
	    </p>

	    <p>
	      4. Find the new centers that are born when you apply the
	      transformation to the old center.  Does the new
	      combination make things stronger?  Prettier?  More functional?
	    </p>

	    <p>
	      5. Ensure that you did the simplest possible thing.
	    </p>

	    <p>
	      6. Go back to the beginning for the next step.
	    </p>

	    <p>
	      A super-short summary could be, "find the bad parts;
	      make them better in the simplest way possible; repeat
	      until it is all good".
	    </p>

	    <p>
	      <strong>What the hell does this have to do with software design?</strong>
	    </p>

	    <p>
	      Let me give you some examples.
	    </p>

	    <p>
	      <a
	      href="http://en.wikipedia.org/wiki/Code_refactoring">Refactoring</a>
	      is just applying structure-preserving transformations.
	      You don't change what the program does; you just change
	      how it is built internally, piece by piece.
	    </p>

	    <p>
	      <a
	      href="http://www.joelonsoftware.com/articles/fog0000000069.html">You
	      do not rewrite software</a>; you fix the software that
	      exists.  Otherwise you lose all that knowledge, even if
	      it looks ugly in its curent state.
	    </p>

	    <p>
	      You don't design the whole user interface for a big
	      program in a single step.  You go from big to small or
	      small to big (<strong>levels of scale</strong>); you
	      test each part individually until it is good
	      (<strong>strong centers</strong>); you make sure the
	      parts are not too disconnected from each other
	      (<strong>non-separateness</strong>).  You move a few
	      widgets where they are easier to reach, or where they
	      are closer to the data to which they refer.  You remove
	      some frames and separators to reduce clutter.
	    </p>

	    <p>
	      <strong>Free software and cities</strong>
	    </p>

	    <p>
	      We software developers are building cities.  I include
	      code hackers, designers, translators, documenters,
	      etc. in the term "developers" &mdash; building cities of
	      software programs interconnected with each other through
	      IPC.  Each program is a building, large or small, simple
	      or complex, each with a different purpose and layout.
	    </p>

	    <p>
	      Designing a whole system (kernel, libraries, tools,
	      shell, programs) would be like trying to design a whole city.
	      <strong><a
	      href="http://emergenturbanism.com/2009/03/23/the-journey-to-emergence/">A
	      good city cannot be designed</a></strong>; it has to emerge from
	      the interactions between its inhabitants, over many
	      years.  Good cities are emergent, not designed.
	      Ecosystems emerge from the interactions of living and
	      non-living beings; they are not designed and they always
	      evolve.
	    </p>

	    <p>
	      Remember that no one can work on <em>all</em> of free
	      software.  You cannot design a whole system by yourself, and you
	      cannot make everyone agree on everything for a perfectly
	      consistent design.  But if you follow the
	      structure-preserving transformations and the fundamental
	      process, you can build your part of a big system and it
	      will automatically be harmonious with everything else
	      &mdash; and you will have fixed the bad parts first,
	      making the overall <em>goodness</em> much better.
	    </p>

	    <p>
	      So, go forth and design and build and iterate.
	    </p>


Alexander's work

Sacar ideas de ~/Documents/Gnome/programming-guidelines.txt

Sacar ideas del Foreword de Patterns of Software, por Alexander.


Richard Gabriel applied Alexander's stuff to poetry - and it works!
And to code as well.


Intro to Alexander for object-oriented designers - http://gee.cs.oswego.edu/dl/ca/ca/ca.html



Has all of this stuff let me do better work?
Are my programs better as a result?


It turns out that the authors of "Design Patterns" were directly
inspired by Alexander's work.



Not doing evidence-based design/construction is foolish.  Why?

How do we avoid constant trial-and-error?

How to use Alexander's work for software

Where to learn more

From http://bertrandmeyer.com/2010/07/30/empirical-software-engineering-the-good-news/

	What triggered this radical change is the availability of
        open-source repositories. Projects such as Linux, Eclipse,
        Apache, EiffelStudio and many others have records going back
        10, 15, sometimes 20 years. These records contain the true
        history of the project: commits (into the configuration
        management system), bug reports, bug fixes, test runs and
        their results, developers involved, and many more elements of
        project data. All of a sudden empirical research has what any
        empirical science needs: a large corpus of objects to analyze.

From http://bertrandmeyer.com/2010/07/31/the-rise-of-software-engineering-ii-what-we-are-still-missing/ 

	One component of the experimental method is still not quite
        there: reproducibility. It is essential to the soundness of
        natural sciences; when you publish a result there, the
        expectation is that others will be able to replicate it.

As you build, you come to points in which you must make decisions.
You can lay bricks in a row for a few minutes (or write code that
"writes itself"), but then you need to make a decision.  This method
lets you make the right decision, or *a* right decision.  CA
calculated the number of mistakes in a building per unit volume.


Whatever we teach [decide] should be falsifiable.


"they reach the life of buildings, by a continuous unfolding process
in which structure evolves almost continuously, under the criterion of
emerging life, and does not stop until life is actually achieved.  The
trick is, that this is accomplished with finite means, and without
back-tracking." - from the foreword to Patterns of Software.


What have you (FMQ) refactored with really good results?  Do you have
the git log?


Tight coupling, loose coupling.

Hierarchy of components / hierarchy of scale.

37signals - Notes on the Sythesis of Form

La presentación de cómo diseñar una página de web.


Workspace enclosure - is that where they compiled statistics of what
people liked and didn't?

Traditional architectures *evolved* over hundreds or thousands of
years.  Programming has not had such a long history yet.

Design Patterns and Refactoring gave us a *vocabulary* for things we
commonly do.  Just like architecture has its own vocabulary of beams,
rafters, and joists, so do we now have vocabulary like a map-reduce
process, an object factory, or a [refactoring term].

We are building new kinds of software.  We are not building the "same"
kind of bridge over and over again, wherever it is needed.  Software
doesn't want such re-construction; we can just copy it if we need it
again.  So it practically wants us to write new things all the time.
So how do we go about that?

Richard Gabriel in POS - "An image I like to use is that every large
software project is similar to the first attempt to build a
flying-buttress construction cathedral. Imagine how many of them
collapsed before we figured out how to build them."


"Habitability is the characteristic of source code that enables
programmers, coders, bug-fixers, and people coming to the code later
in its life to understand its construction and intentions and to
change it comfortably and confidently. [...]  Habitability makes a
place livable, like home. And this is what we want in soft- ware—that
developers feel at home, can place their hands on any item without
having to think deeply about where it is." [POS, p. 11]

"Habitability is related to a concept called organic order that Christopher Alex-
ander, the architect, uses in his work:
         Organic Order: . . . the kind of order that is achieved when there is a
         perfect balance between the needs of the parts and the needs of the
         whole. (Alexander 1975)
" [POS, p. 11]

"Buildings like the Superdome [in New Orleans] lack habitability. In
this instance people inhabit the building, but only for very short
periods of time, and for very special occa- sions—and such buildings
are not easily grown or altered. The Superdome is a static building,
and therefore it can stand as a monument, being little else." [POS,
p. 12] - Find picture of the superdome

"    Contrast this with the New England farmhouse. It starts as a small home with
a barn out back. As the family grows and the needs of the farm grow, a back room
is added to the house, then a canning room, then a room for grandma; stables are
added to the barn, then a wing for milking more cows. Finally the house and barn
are connected because it is too difficult to get from the house to the barn in a bliz-
zard. The result is rambling, but each part is well-suited to its needs, each part fits
well with the others, and the result is beautiful because it is a living structure with
living people inside. The inhabitants are able to modify their environment
because each part is built according to familiar patterns of design, use, and con-
struction and because those patterns contain the seeds for piecemeal
growth." [POS, p. 12] - Find picture of a New England farmhouse

"In Alexander’s definition of organic order applied to software, the
concept of “needs of the whole” refers to the grand design or
architecture of the piece of soft- ware under development, and “needs
of the parts” refers to the inevitable changes the various parts of
the software undergo. It’s difficult to change the grand design of
software: You cannot expect to evolve a window system into a
spreadsheet.  Although the primary need of the whole is to remain true
to its essence, the parts often must change. For instance, one sort of
window system could evolve into another." [POS, p. 12]

"Software needs to be habitable because it always has to
change. Software is sub- ject to unpredictable events: Requirements
change because the marketplace changes, competitors change, parts of
the design are shown wrong by experience, people learn to use the
software in ways not anticipated. Notice that frequently the
unpredictable event is about people and society rather than about
technical issues. Such unpredictable events lead to the needs of the
parts which must be comfortably understood so they can be comfortably
changed." [POS, p. 13]

"    Consider bugs. Many a bug is the result of not anticipating a particular event
or use and is not the result of a mistake—bugs are not always errors. Bugs tell us
that we are not capable of producing a master plan. A master plan is a detailed
design, and many projects consider critical their detailed designs. But a master
plan is usually not possible, especially for extensive, long-lived software. Alex-
ander writes:
          It is simply not possible to fix today what the environment should be
          like [in the future], and then to steer the piecemeal process of devel-
          opment toward that fixed, imaginary world. (Alexander 1975)
    This simply acknowledges that it is impossible to predict the circumstances of
a long-lived program. But there is a more important point:
          Master plans have two additional unhealthy characteristics. To begin
          with, the existence of a master plan alienates the users. . . . After all,
          the very existence of a master plan means, by definition, that the
          members of the community can have little impact on the future shape
          of their community, because most of the important decisions have
          already been made. In a sense, under a master plan people are living
          with a frozen future, able to aff ect only relatively trivial details.
          When people lose the sense of responsibility for the environment they
          live in, and realize that there are merely cogs in someone else’s
          machine, how can they feel any sense of identification with the com-
          munity, or any sense of purpose there?
              Second, neither the users nor the key decision makers can visualize
          the actual implications of the master plan. (Alexander 1975)
" [POS, p. 13]

"As I said earlier, a New England farmhouse is habitable, and the new
owner feels just as comfortable changing or adapting that farmhouse as
the first farmer was. But a home designed by Frank Lloyd Wright—though
more hab- itable than most “overdesigned” homes—cannot be altered
because all its parts are too rigidly designed and built. The needs of
the whole have overshadowed the needs of the parts and the needs of
the inhabitants." [POS, p. 14] - Find pictures of Fallingwater and such.

"The principle of organic order: Planning and construction [imple-
mentation, in our context] will be guided by a process which allows
the whole to emerge gradually from local acts. (Alexander 1975)" [POS,
p. 14]

"[...] there are very few completed programs, because programs are written,
maintained, bugs are fixed, features are added, performance is tuned,
and a whole variety of changes are made both by the original and new
programming team members. Thus, the way a program looks in the end is
not important because there is rarely an end, and if there is one it
isn’t planned.  " [POS, p. 15]

"If the beauty of the code gets in the way, the program is not well
written, just as an office building designed to win design awards is
not well designed when the building later must undergo changes but
those changes are too hard to make.  " [POS, p. 15]

"The danger of clarity is that it is uncompromised beauty; and it’s
real tough to to improve uncompromised beauty. Many second- and
third-rate sculptors can fix a decent sculpture—I saw a group of them
one summer making replacement gargoyles for Notre Dame Cathedral in
Paris—but which of them would dare repair Michelangelo’s David? Who
would add a skyscraper to the background of Mona Lisa? Who would edit
Eliot’s poems? Clarity is dangerous." [POS, p. 16]

The ticket booth example - POS, p. 35 (see the following, plus the
text before it):

	So it became clear that the free functioning of the system did
	not purely depend on meeting a set of requirements. It had to
	do, rather, with the system coming to terms with itself and
	being in balance with the forces that were generated internal
	to the system, not in accor- dance with some arbitrary set of
	requirements we stated. I was very puzzled by this because the
	general prevailing idea at the time [in 1964] was that
	essentially everything was based on goals. My whole analysis
	of requirements was certainly quite congruent with the oper-
	ations research point of view that goals had to be stated and
	so on.  What bothered me was that the correct analysis of the
	ticket booth could not be based purely on one’s goals, that
	there were realities emerging from the center of the system
	itself and that whether you succeeded or not had to do with
	whether you created a configuration that was stable with
	respect to these realities. (Grabow 1983)

Quality without a name: alive, whole, comfortable, free, exact,
egoless, and eternal. (POS, p. 36 - look from there for the
definitions)

A system subtly free from internal contradictions, or inner forces
that can tear it apart.  


Division of value:  objective (wholeness) and subjective (beauty) parts.


References

A Pattern Language

Photos and drawings of the fifteen properties of life - http://www.livingneighborhoods.org/ht-0/fifteen.htm

Patterns of Software

AlexanderPresentation.pdf
NatureOfOrder.pdf
